import java.io.File
import java.util.regex.Pattern
import java.util.regex.Matcher
import org.apache.tools.ant.PropertyHelper

class PentahoProjectPlugin implements Plugin<Project> {
  private PropertyHelper getBuildPropertyHelper(Project project) {
    def buildProperties = new Properties()
    def buildFile = new File(project.projectDir.absolutePath + '/build.properties')
    if (!buildFile.exists()) {
      buildFile = new File(project.projectDir.absolutePath + '/assembly.properties')
    }
    if (buildFile.exists()) {
      println "Project $project.name Loaded build file $buildFile.absolutePath"
    }
    if (buildFile.exists()) {
      buildProperties.load(new FileReader(buildFile))
    }
    def propertyHelper = PropertyHelper.getPropertyHelper(new org.apache.tools.ant.Project())
    buildProperties.each{k, v -> propertyHelper.setProperty(null, k, v, true)}
    return propertyHelper
  }

  public void apply(project) {
    def propertyHelper = null
    if (project.hasProperty('propertyHelper')) {
      propertyHelper = project.ext['propertyHelper']
    } else {
      propertyHelper = getBuildPropertyHelper(project)
    }
    def archiveTask = project.tasks.create('dist', Zip)
    archiveTask.duplicatesStrategy 'exclude'

    def srcZipTask = project.tasks.create('srcZip', Zip)
    srcZipTask.archiveName propertyHelper.replaceProperties('${ivy.artifact.id}-${project.revision}-sources.zip')
    srcZipTask.duplicatesStrategy 'exclude'
    srcZipTask.into('') { from project.sourceSets*.allSource }

    project.configurations.create('zip')
    project.artifacts {
      zip archiveTask
    }

    archiveTask.dependsOn(project.tasks['jar'])

    project.afterEvaluate {
      if (project.ext.has('assemble')) {
        project.ext['assemble'].each { entry ->
          def to = entry.get('to', '')
          def fromType = entry.get('fromType', 'configuration')
          def newSpec = project.copySpec {}
          def filterSpecs = entry.get('filterSpecs', [])
          filterSpecs.each { filterSpec -> 
            filterSpec['pattern'] = Pattern.compile(filterSpec['pattern'])
            def find = filterSpec['find']
            if (find != null) {
              filterSpec['find'] = Pattern.compile(find)
            }
          }

          if ('folder'.equals(fromType) || 'file'.equals(fromType)) {
            newSpec.into(to) { from entry['from'] }
          } else if ('configurationZip'.equals(fromType)) {
            project.configurations.findByName(entry['from']).files.each { file ->
              newSpec.into(to) { from project.zipTree(file.absolutePath) }
            }
          } else if ('srcZip'.equals(fromType)) {
            archiveTask.dependsOn(srcZipTask)
            newSpec.into(to) { from srcZipTask.archivePath }
          } else if ('outputJar'.equals(fromType)) {
            newSpec.into(to) { from project.jar.archivePath }
          } else {
            newSpec.into(to) { from project.configurations.findByName(entry['from']) }
          }
          newSpec.duplicatesStrategy = 'exclude'
          newSpec.eachFile { fileCopyDetails ->
            def absolutePath = fileCopyDetails.file.absolutePath
            def descriptions = []
            filterSpecs.each { filterSpec ->
              if (filterSpec['pattern'].matcher(absolutePath).find()) {
                def operation = filterSpec['operation']
                def description = operation
                if ('exclude'.equals(operation)) {
                  fileCopyDetails.exclude()
                } else if ('replace'.equals(operation)) {
                  def replacement = Matcher.quoteReplacement(propertyHelper.replaceProperties(filterSpec['replacement']))
                  fileCopyDetails.filter { line -> filterSpec['find'].matcher(line).replaceAll(replacement) }
                  description = description + " " + filterSpec['find'] + " with " + filterSpec['replacement']
                } else if ('chmod'.equals(operation)) {
                  fileCopyDetails.setMode(Integer.parseInt(filterSpec['permissions'], 8))
                  description = description + " " + filterSpec['permissions']
                }
                descriptions.add(description)
              }
            }
            if (descriptions.size() > 0) {
              println "Applied the following filterSpecs to " + absolutePath
              descriptions.each { description -> println "    $description" }
            }
          }
          archiveTask.with(newSpec)
        }
      }
      project.configurations['compile'].allDependencies.each { dependency ->
        if (dependency instanceof ProjectDependency) {
          srcZipTask.into('') { from dependency.dependencyProject.sourceSets*.allSource }
        }
      }
      project.configurations.each { configuration ->
        configuration.allDependencies.each { dependency ->
          if (dependency instanceof ProjectDependency && dependency.configuration.equals('zip')) {
              archiveTask.dependsOn(dependency.dependencyProject.tasks['dist'])
          }
        }
      }
    }
  }
}

project.ext['pentaho-dist'] = PentahoProjectPlugin.class
