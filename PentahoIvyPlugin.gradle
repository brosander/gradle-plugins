import org.gradle.api.plugins.JavaPlugin

class PentahoIvyPlugin implements Plugin<Project> {
  def buildProperties 
  def confMappingProperty = 'pentaho-ivy-conf-mapping'
  def globalToLocalMapProperty = 'pentaho-global-to-local-mapping'
  def project

  //Will replace property references with their values in build.properties or assembly.properties for use at build time
  def propertyHelper = org.apache.tools.ant.PropertyHelper.getPropertyHelper(new org.apache.tools.ant.Project())

  //Will replace property references with a string that will resolve them for use in build.gradle
  def printPropertyHelper = org.apache.tools.ant.PropertyHelper.getPropertyHelper(new org.apache.tools.ant.Project())
  def engine = new groovy.text.SimpleTemplateEngine()

  def getIvyConfMapping(String ivyConf) {
    if (ivyConf.contains('->')) {
      ivyConf = ivyConf.split('->')[0]
    }
    def result = project.getProperty(confMappingProperty).get(ivyConf)
    if (result == null) {
      result = ivyConf
    }
    Configuration configuration = project.configurations.findByName(result);
    if (configuration == null) {
      configuration = project.configurations.create(result);
    }
    return result
  }

  def getArtifactInfo(String ivyLocation) {
    if (new java.io.File(ivyLocation).exists()) {
      def parsedIvy = new XmlParser().parse(ivyLocation)
      for (info in parsedIvy.info) {
        return propertyHelper.replaceProperties(info.@organisation) + ':' + propertyHelper.replaceProperties(info.@module) + ':' + propertyHelper.replaceProperties(info.@revision)
      }
    }
  }

  def registerDependencies(String ivyLocation, Closure registerAction) {
    if (new java.io.File(ivyLocation).exists()) {
      def parsedIvy = new XmlParser().parse(ivyLocation)
      parsedIvy.dependencies.each { dependencies ->
        def defaultConf = getIvyConfMapping((dependencies.@defaultconf).split('->')[0])
        dependencies.dependency.each { dependency ->
          def dependencyNotation = [ 'group'   : propertyHelper.replaceProperties(dependency.@org),
                                     'name'    : propertyHelper.replaceProperties(dependency.@name),
                                     'version' : propertyHelper.replaceProperties(dependency.@rev) ]
          def register = { extension ->
            if (extension != null) {
              dependencyNotation['ext'] = extension
            }
            def dependencyProject = project.ext[globalToLocalMapProperty][propertyHelper.replaceProperties(dependency.@org + ':' + dependency.@name + ':' + dependency.@rev)]
            def isTransitive = true
            if (dependency.@transitive != null && !'true'.equalsIgnoreCase(dependency.@transitive)) {
              isTransitive = false
            }
            def changing = false
            if (dependency.@changing != null && 'true'.equalsIgnoreCase(dependency.@changing)) {
              changing = true
            }
            if (dependency.@conf != null) {
              registerAction(dependency.@conf, dependencyNotation, dependencyProject, isTransitive, changing)
            } else {
              registerAction(defaultConf, dependencyNotation, dependencyProject, isTransitive, changing)
            }
          }
          if (dependency.artifact.size() == 0) {
            register(null)
          } else {
            dependency.artifact.each { artifact ->
              register(artifact.@type)
            }
          }
        }
      }
    }
  }

  void apply(Project project) {
    this.project = project
    def buildProperties = new Properties()
    def buildFile = new File(project.projectDir.absolutePath + '/build.properties')
    if (!buildFile.exists()) {
      buildFile = new File(project.projectDir.absolutePath + '/assembly.properties')
    } 
    if (buildFile.exists()) {
      println "Project $project.name Loaded build file $buildFile.absolutePath"
    }
    if (buildFile.exists()) {
      buildProperties.load(new FileReader(buildFile))
    }
    this.buildProperties = buildProperties
    buildProperties.each{k, v -> propertyHelper.setProperty(null, k, v, true)}
    buildProperties.each{k, v -> printPropertyHelper.setProperty(null, k, '${property(\'' + k + '\')}', true)}

    if (!project.hasProperty(confMappingProperty)) {
      project.ext[confMappingProperty] = new HashMap()
    }
    def confMapping = project.getProperty(confMappingProperty)
    if (!confMapping.containsKey('default')) {
      confMapping.put('default', 'compile')
    }
    if (!confMapping.containsKey('test')) {
      confMapping.put('test', 'testCompile')
    }

    if (!project.hasProperty(globalToLocalMapProperty)) {
      project.ext[globalToLocalMapProperty] = new HashMap()
    }
    def globalToLocalMap = project.getProperty(globalToLocalMapProperty)
    

    project.repositories {
      ivy {
        url "http://repo.pentaho.org/artifactory/repo/"
        layout  "pattern", {
          ivy "[organisation]/[module]/[revision]/[module]-[revision].ivy.xml"
          artifact "[organisation]/[module]/[revision]/[module]-[revision].[ext]"
          m2compatible = true
        }
      }
      maven {
        url 'http://repo.pentaho.org/artifactory/repo'
      }
      mavenCentral()
    }

    buildProperties.each{k, v -> 
      if (!project.hasProperty(k)) {
        project.ext[k] = v
      }
    }

    def ivyLocation = project.projectDir.absolutePath + "/ivy.xml"

    project.ext[globalToLocalMapProperty][getArtifactInfo(ivyLocation)] = project.path
    project.ext['ivy-messages'] = []
    project.plugins.apply(JavaPlugin)
    project.archivesBaseName = propertyHelper.replaceProperties(buildProperties['ivy.artifact.id'])
    project.version = propertyHelper.replaceProperties(buildProperties['project.revision'])
    
    project.beforeEvaluate {
      registerDependencies(ivyLocation, {conf, notation, otherProject, isTransitive, isChanging -> 
        if (otherProject == null) {
          if ('kettle' in notation['name'] ) {
            println notation
          }
          project.getDependencies().add(getIvyConfMapping(conf), notation, {
            transitive isTransitive
            changing isChanging
          })
        } else {
          project.ext['ivy-messages'].add(getIvyConfMapping(conf) + " project('" + otherProject + "')")
        }
      })
      project.configurations.each { configuration ->
        project.ext[globalToLocalMapProperty].each { key, value ->
          def split = key.split(':')
          configuration.exclude(['group': split[0], 'module' : split[1]])
        }
      }
    }

    project.task('print-deps') << {
      if (project.ext['ivy-messages']) {
        println "dependencies {"
        project.ext['ivy-messages'].each { message ->
          println "  " + message
        }
        println "}"
      } else {
        println project.path + " has no interdependencies."
      }
    }

    project.task('print-ivy') << {
      registerDependencies(ivyLocation, {conf, notation, otherProject, isTransitive, isChanging -> println getIvyConfMapping(conf) + ' "' + printPropertyHelper.replaceProperties(notation) + "\", {transitive = $isTransitive; changing = $isChanging}"})
    }
  }
}

project.ext['pentaho-ivy'] = PentahoIvyPlugin.class
